{ config, lib, inputs, ... }:

{
  options.rust = {
    toolchain = lib.mkOption {
      type = let
        toolchainModule = { ... }: {
          options.channel = lib.mkOption {
            type = lib.types.enum [ "stable" "beta" "nightly" ];
            default = "stable";
            description = "Rust toolchain channel.";
          };

          options.version = lib.mkOption {
            type = lib.types.str;
            default = "latest";
            description = "Rust toolchain version.";
          };

          options.profile = lib.mkOption {
            type = lib.types.enum [ "minimal" "default" "complete" ];
            default = "default";
            description = "Rust toolchain profile.";
          };

          options.extensions = lib.mkOption {
            type = lib.types.listOf lib.types.str;
            default = [ "rust-analyzer" ];
            description = "Additional Rust components to install.";
          };
        };
      in lib.types.submodule toolchainModule;
      description = "Rust toolchain from rust-overlay.";
    };

    workspace = {
      check = lib.mkOption {
        type = lib.types.bool;
        default = true;
        description = "Whether to run tests in the workspace by default.";
      };

      cargo-nix = lib.mkOption {
        type = lib.types.path;
        description = "Cargo.nix generated by crate2nix.";
      };

      default = lib.mkOption {
        type = with lib.types; nullOr (functionTo attrs);
        default = null;
      };
    };
  };

  config = let
    cfg = config.rust;
    assertions = [
      {
        assertion = let
          cargo-nix = import cfg.workspace.cargo-nix {};
          is-crate = builtins.hasAttr "rootCrate" cargo-nix;
        in !is-crate || cfg.workspace.default == null;

        message = "If Cargo.nix defines a workspace, `rust.workspace.default` must be null.";
      }
    ];
    assertOne = item: lib.assertMsg item.assertion item.message;
    assertAll = items: lib.foldl' (acc: assertOne) true items;
  in lib.mkIf (assertAll assertions) {
    perSystem = { system, ... }: let
      pkgs = import inputs.nixpkgs {
        inherit system;
        overlays = [ inputs.rust-overlay.overlays.default ];
      };

      rust-toolchain = with cfg.toolchain; let
        base = if channel == "nightly" && version == "latest" then
          pkgs.rust-bin.selectLatestNightlyWith (toolchain: toolchain)
        else
          pkgs.rust-bin.${channel}.${version};
      in base.${profile}.override { inherit extensions; };

      cargo-nix = import cfg.workspace.cargo-nix {
        inherit pkgs;
        buildRustCrateForPkgs = crate: pkgs.buildRustCrate.override {
          rustc = rust-toolchain;
          cargo = rust-toolchain;
        };
      };
    in rec {
      devShells.default = pkgs.mkShell {
        name = "rust";
        packages = [
          pkgs.crate2nix
          rust-toolchain
        ];
      };

      checks = let
        mkCheck = name: build:
          build.override { runTests = true; };
      in lib.mkIf cfg.workspace.check (
        lib.mapAttrs mkCheck packages
      );

      packages = let
        others =
          if builtins.hasAttr "rootCrate" cargo-nix then
            { ${cargo-nix.rootCrate.packageId} = packages.default; }
          else
            cargo-nix.workspaceMembers;

        default =
          if builtins.hasAttr "rootCrate" cargo-nix then
            { default = cargo-nix.rootCrate; }
          else if cfg.workspace.default != null then
            { default = cfg.workspace.default cargo-nix.workspaceMembers; }
          else
            {};
      in builtins.mapAttrs (_: crate: crate.build) (others // default);
    };
  };
}
